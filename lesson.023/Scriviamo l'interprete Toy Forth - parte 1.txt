0:40 Bene, bene. A questo punto siamo in una fase  evoluta di questo corso di programmazione in C,  
0:45 nel senso che abbiamo esplorato una quantità di  concetti di questo linguaggio, dalle strutture ai  
0:53 puntatori a funzione, a come si usano i puntatori  per manipolare i dati in memoria, e così via, che  
1:01 possiamo dire di avere una quantità sufficiente di  strumenti per cimentarci a fare qualcosa di vero.
1:08 Perché noi potremmo continuare nell'esporre delle  funzionalità del C o della libreria standard,  
1:14 o potremmo addentrarci, come faremo prima  o poi, nelle chiamate di sistema POSIX,  
1:20 ma per imparare a usare il C davvero (e non  è una questione che è limitata solo a questo  
1:26 linguaggio di programmazione, ma per imparare a  programmare in maniera forte) bisogna capire come  
1:33 questi strumenti si mettono assieme quando  si deve realizzare qualcosa di non banale.
1:39 Una cosa non banale è un interprete  per un linguaggio di programmazione,   e il più semplice linguaggio di programmazione  che noi possiamo scrivere, a iniziare da  
1:47 questa lezione (non credo che finiremo in 20  minuti), è una versione giocattolo di Forth.
1:55 Forth è un linguaggio basato sullo stack.  Per esempio un programma Forth, o meglio,  
2:02 qui non utilizzeremo davvero la sintassi esatta  di Forth in tutti i casi, ma di questo ideale  
2:09 linguaggio di programmazione che noi vogliamo  scrivere. Però, per esempio, se io scrivo 5 5 + è  
2:15 un programma che somma il numero 5 col numero 5,  o potrei scrivere lo stesso programma come 5 DUP.
2:24 Andiamo a vedere cos'è che fanno questi  programmi e che cos'è un linguaggio di   programmazione basato sullo stack. Quindi  io faccio finta, questo è il programma uno  
2:33 e questo è il programma 2. Sono due programmi  diversi. Facciamo finta di essere l'interprete. Inizio dal programma 1. 5. Io ho una pila che si  chiama lo stack di valori. Quando incontro cinque,  
2:45 che è un valore letterale, io metto cinque  nello stack. Questo è il mio stack. Il mio  
2:52 stack ora contiene cinque. Poi, quindi questa  parola... allora, i linguaggi stack sono basati  
3:00 sull'idea di "parola", è una sequenza di parole,  quindi sostanzialmente il programma è una lista.
3:06 Vado alla seconda parola e c'è  di nuovo cinque. Siccome è sempre   un valore e non è una funzione, io  accodo di nuovo cinque al mio stack.
3:19 Finalmente trovo come terza parola del mio  programma una funzione. Siccome questa è una  
3:26 funzione, io invoco questa funzione, "+". Questa  funzione fa di prelevare i due valori sullo stack,  
3:34 che sono gli ultimi due che sono stati inseriti,  quindi i due valori in cima allo stack.  
3:42 Li somma, quindi li preleva (non ci sono  più, ma ci sono, diciamo, qua ora dentro  
3:48 il contesto della funzione "+"), li preleva,  li somma e questo è il risultato, e inserisce  
3:55 nello stack il valore risultato. Quindi il mio  stack varrà 10 alla fine di questo programma.
4:04 Andiamo ora ad eseguire, partendo con lo stack  vuoto, il programma numero due. Incontro 5 e,  
4:10 siccome è un valore, lo metto dentro lo stack.  Incontro stavolta direttamente una funzione:  
4:15 DUP. DUP fa questa cosa: preleva o, possiamo  dire che, o preleva dallo stack il valore più  
4:26 in cima (5) e lo inserisce due volte, o  potremmo dire che (è un'alternativa di  
4:34 implementazione) guarda che valore c'è  in cima allo stack e lo reinserisce.  
4:40 Comunque il risultato è di duplicare  l'ultimo valore in cima allo stack.
4:45 Quindi io c'ho qua 5 e 5, e poi quando incontro  "+" succede quello che succedeva prima. Prendo 5  
4:53 e 5, li sommo, li prelevo dello stack,  li sommo e metto 10 come risultato.
5:00 Un linguaggio stack-based fa esattamente  questo. Uno potrebbe chiedersi: "Ma come  
5:09 faccio poi ad andare oltre? Come faccio a  fare una if? Come faccio a fare un ciclo?  
5:17 E tutte queste cose?". Lo vedremo dopo,  però ve lo voglio accennare immediatamente.
5:23 Io ho visto che cinque è un valore. Può  essere anche un valore... per esempio,   un programma valido potrebbe essere "Hello World"  strlen. Questo programma avrà questo effetto:  
5:38 io prima incontro questo valore stringa, lo  metto sullo stack. Poi c'ho questa funzione  
5:45 strlen che prende il valore in cima  allo stack (la stringa) e lo preleva  
5:55 (quindi non c'è più). Guarda quanto è  lunga questa stringa: 1 2 3 4 5 6 7 8 9  
6:00 10 11. E mette sullo stack il valore 11. E  poi magari potevo avere anche una "print",  
6:07 e la print preleva dallo stack l'ultimo  valore e lo stampa a video. Quindi il  
6:14 risultato sarebbe stato di avere 11 stampato a  video. Quindi questo è l'output del programma.
6:24 Ora, visto che i diversi valori  possono essere non solo numerici,  
6:30 perché io non potrei avere come valore  un sottoprogramma? Abbiamo detto che  
6:37 un programma alla fine in questo  tipo di linguaggio è una lista, OK? Quindi io posso fare, per esempio, che... [ DUP  * ]. Quindi sostanzialmente questo programma qui  
6:49 farebbe l'elevazione al quadrato del numero che  c'è in cima allo stack, perché DUP lo duplica   e * fa l'uno per l'altro, e siccome i due valori  sono uguali è x * x, quindi eleva al quadrato.
7:02 Ma io posso fare invece anche DUP.  Quindi questi sono due sottoprogrammi,   e questa è il ramo vero della if.  Questo è il ramo falso della if. E  
7:12 qua ci metto un'espressione che è quella  che deve essere verificata. Per esempio,   "se 10 è 20", if. Qua a questo punto  è anche questo un sottoprogramma.
7:27 Eh no, scusate, ho sbagliato.  Ecco, così. In sostanza quello   che succede... guardate in questo programma  che cosa succede, com'è implementata la if.
7:39 Quindi c'ho questo stack. Incontro un primo  valore. Questo è un valore che è una lista che,  
7:45 guarda caso, rappresenta un programma, e  lo metto nel mio stack. Incontro il secondo  
7:50 valore e lo metto nel mio stack. Incontro  il terzo valore... però questo qui, scusate,  
7:57 dovevo scriverlo così, perché l'operatore  qua va sempre a destra. Prima devo fare il  
8:03 push nello stack dei miei valori e poi c'è  la mia funzione che opera sui valori. OK?  
8:08 Comunque questo significa "10 20 <". Bisogna  un po' abituarsi alla sintassi, lo capisco.
8:15 Quindi metto anche questa lista, che però  rappresenta un programma, nel mio stack.  
8:20 Quando poi viene chiamata la IF, alla fine la IF  non fa che prelevare tutta 'sta roba dallo stack.  
8:27 Prima esegue questo sottoprogramma qui, il  terzo. Quindi tutti e tre gli argomenti della  
8:33 if devono essere liste di questo nostro  linguaggio di programmazione valide.
8:39 Lo esegue. Quindi 10 < 20? Sì. Quindi  restituisce "true" nello stack.  
8:47 Vabbè, neanche ci passa allo  stack, semplicemente guarda se   quell'espressione ritorna un valore vero.  O meglio, siccome esegue il programma,  
8:58 va a finire effettivamente nello stack, perché  sta eseguendo un programma e quindi noi abbiamo  
9:04 uno stack unico e globale in questo linguaggio  di programmazione, e quindi qua diventa "true".
9:09 Poi preleva dallo stack questo valore, lo osserva:  se è vero, esegue il primo sottoprogramma che ha  
9:19 prelevato; se è falso, esegue il secondo  sottoprogramma. In questo caso è true,   quindi... vabbè, facciamo finta  che prima lo stack aveva qua 20,  
9:27 prima ancora di esserci quel "true" che avevamo  inserito. Quindi esegue questo sottoprogramma,   duplica il valore, lo moltiplica, e  quindi 20 * 20... 2 * 2 = 4... fa 400.  
9:40 E qui lo stack avrà solo 400. Quindi si  possono implementare anche le condizionali.
9:48 Voi direte: "Caspita, ma è strana  una condizionale scritta così?".   Però poi ci aiuta il fatto di scriverla così.
9:59 Magari questi qua si possono anche indentare così: [ ... ]  [ ... ] 10 20 < 
10:05 if  OK? Quindi, praticamente, l'indentazione  funzionerebbe in questo caso esattamente  
10:11 al contrario. Sono dei linguaggi che  hanno una logica, diciamo, diversa.
10:18 In realtà, per rendere questo programma più  leggibile, è meglio se la condizione è il   primo argomento. In questo modo il programma  diventa più leggibile, perché diventa così:  
10:34 [condizione] [questo] o [questo] if. Mi sembra  un modo più interessante di strutturarlo.
10:43 E poi inoltre è anche vero che questo  qui si dovrebbe chiamare "if else",   perché "if" sarebbe la forma più compatta,  in cui io posso fare [condizione] [...] if.  
10:54 Quindi questa operazione viene svolta solo  se in effetti questo programma qui è vero.
11:01 Bene, come si fa a fare tutta 'sta roba qui?   Dobbiamo usare ovviamente le strutture per  rappresentare i nostri oggetti, dobbiamo  
11:09 usare i puntatori per fare il parsing di questo  programma, dobbiamo usare i puntatori a funzione  
11:14 (probabilmente, ora vedremo) per modellare  comunque i diversi tipi di comandi che, diciamo,  
11:23 di funzioni che questo nostro linguaggio  di programmazione accetta, e così via.  
11:28 Questo mi sembra comunque veramente mettere  assieme tanta della roba che noi c'eravamo detti.
11:35 La prima cosa da fare quando si  scrive... Allora, questo qui,   siccome sono tutti derivati dal Forth,  chiamiamolo ToyForth. Quando si crea un  
11:46 programma di una certa complessità,  è bene partire dalle strutture dati. Quindi io avrò una rappresentazione degli  oggetti di questo linguaggio di programmazione,  
11:55 la posso chiamare struct... TF o ToyForthObject. E avrà questo ToyObject un "type", perché può  
12:11 essere un intero, una stringa... una...  può essere tante cose che ora vedremo.
12:19 Beh, qua definiamo: TF_OBJECT_TYPE_INT 0 
12:26 TF_OBJECT_TYPE_STR 1 Qua si potevano usare  
12:32 delle enum, che noi non abbiamo ancora trattato,  ma comunque è equivalente, non è questo il punto.  
12:38 Il punto è capire come si mettono assieme le  cose ad alto livello, dal basso all'alto livello.
12:43 ...STR... LIST... anzi prima i booleani,  perché poi abbiamo le comparazioni per fare  
12:54 appunto cicli if, cicli for e tutte  le cose qua che ci possono servire. 
13:03 Forse che poi la lista comunque è anche il  tipo nativo del linguaggio, quando si vuole,  
13:09 diciamo, appunto, programmare. Che poi la lista è, tra l'altro,  
13:17 la stessa rappresentazione che si usa per  i programmi stessi in questo ToyForth.
13:22 Dopodiché qui dobbiamo usare una union, le nostre  union anonime di cui avevamo parlato. Allora,  
13:30 in base al tipo, ovviamente qui  vogliamo un "i" intero... o meglio,  
13:37 forse qui facciamo una cosa. Allora,  int... in realtà ci servirebbero, vabbè,   anche tipi di floating point, ma ci incasiniamo  troppo. Per ora facciamo le cose semplici.
13:48 Poi la stringa sarebbe struct  str. Qua ci vuole un char *ptr,  
14:01 size_t len, perché la nostra stringa deve avere un  puntatore, dobbiamo sapere anche quanto è lunga,  
14:08 e così non abbiamo neanche da crearci problemi  con la null termination eccetera eccetera.
14:15 Poi il booleano, vabbè, lo mettiamo sempre qui,  che poi alla fine è "i", cioè potremmo usare  
14:23 per i booleani potremmo usare benissimo  "i" e forzarlo a essere true o false.
14:29 E invece la lista è la cosa un po' più complicata.  Sostanzialmente è struct tfobj... Allora,  
14:38 struct... ed è un puntatore a un puntatore di...  e la chiamo elements, "ele", e poi size_t len. 
14:55 Allora, qui perché ho fatto questa cosa  qua? Perché qui noi finiremo per avere   questa lista che è un array di puntatori  ad oggetti tfobj, perché ci vanno dentro  
15:07 'sta lista altri oggetti dello stesso  tipo, quindi è una definizione ricorsiva. 
15:14 E quindi il mio array è un puntatore  a dei puntatori di tipo struct tfobj,  
15:24 quindi qua ci vogliono due asterischi e non uno. Questo significa che se io scrivo, per dire,  
15:31 ele[0]... devo togliere un asterisco e quindi mi  ritrovo un puntatore a quell'elemento, d'accordo? 
15:43 E quindi poi lo posso manipolare. Quindi voi  pensate sempre che quando dereferenziate il   puntatore con le parentesi quadre, togliete  un asterisco di qua e quello che vi resta è  
15:52 appunto un puntatore a un oggetto che  poi potete utilizzare come volete.  Quindi qua di solito quello che faremo è:  quando abbiamo una lista, noi avremo un ciclo  
16:01 for e faremo ele[0], ele[1], ele[2], ele[3]... e  avremo tutti i puntatori degli oggetti contenuti.
16:11 Mi sa che per semplificarci la vita  qui ci mettiamo pure un int refcount.  
16:16 Usiamo il reference counting in questo  piccolo linguaggio di programmazione,  
16:22 perché così ci togliamo dalle scatole  una quantità bestiale di cose.
16:29 In realtà noi possiamo usare addirittura...  perché ci servono stack. Avete visto che noi  
16:35 abbiamo gli stack in questo linguaggio,  e lo stack è una cosa fondamentale,   lo stack globale dove i valori vengono inseriti  e tolti. Ma tutto sommato noi possiamo usare la  
16:46 lista come stack, perché questa lista è un array  di elementi. Noi possiamo accodare elementi,   possiamo prenderli dalla fine e toglierli,  insomma, possiamo fare tutto quello che  
16:55 ci serve con la lista. Quindi questa cosa qui  effettivamente la riusciamo a scavalcare così.
17:01 Ci serve anche un'altra cosa. Poi abbiamo  la necessità di avere una funzione che,  
17:07 dato un programma tipo "5 5 DUP" che è una  stringa in C, sostanzialmente, che ci arriva  
17:14 da qualche parte (la leggiamo dal file, ce  la scrive l'utente in modalità interattiva,  
17:20 quel che volete), deve trasformare  questa stringa in un oggetto tfobj.
17:30 Tra l'altro qua facciamo una cosa:   typedef struct tfobj tfobj. Così che noi non  dobbiamo scrivere ogni volta struct tfobj,  
17:43 ma possiamo scrivere tfobj e basta, visto  che lo scriveremo un miliardo di volte.
17:49 Però dicevo, a noi ci serve poi una funzione che,  
17:55 data la stringa del programma, ci ritorna in  realtà un oggetto tfobj che lo ha tokenizzato,  
18:03 lo ha tagliato in parti. Tipo le parti  qui quali sono? Sono il 5, il 5 e DUP.
18:09 Però dobbiamo sapere che... Ah, attenzione però:  questo qui, DUP, è una cosa diversa da tutti  
18:19 'sti tipi qui. È sostanzialmente un simbolo. Si  chiama, diciamo, nel linguaggio di programmazione,  
18:24 negli interpreti, di solito, una cosa che non è  nessun tipo letterale, ma che comunque è... cioè,  
18:32 o meglio, noi chiamiamo questa roba qui, questo  tipo di dato qui che non è tra virgolette ed è  
18:38 una parola singola, non ha caratteri speciali  (o meglio, alcuni caratteri speciali li ha,   perché i simboli possono essere pure "+",  eccetera eccetera). Lo chiamiamo simbolo. 
18:46 Così sappiamo che quando troviamo un simbolo,  noi vogliamo eseguire quel simbolo e non   metterlo dentro lo stack. Eseguendo questo  simbolo, sarà effettivamente associato (poi  
18:56 ci sarà una tabella) che collega il nome  del simbolo alla funzione da chiamare.  Quindi io qua ho bisogno di:  #define TFOBJ_TYPE_SYMBOL 4.
19:12 Allora, qua type... gli mettiamo TFOBJ_TYPE_* per  fare capire che queste define poi sono i valori  
19:21 che prende 'sta roba qui, il type. Qua c'è int i. Facciamo una cosa:  
19:30 noi per il simbolo utilizzeremo  sostanzialmente questo qui, la stringa,   quindi non dobbiamo definire un'altra struttura  perché è questa, no? Puntatore e lunghezza.
19:41 Allora, per fare il parsing, organizzare  questa cosa e trasformarla poi alla fine   in una struttura, a noi ci serve  una struct. Allora, sempre facciamo:  
19:50 typedef struct ToyForthParser TFParser. 
20:05 Allora, per fare il parsing  a noi che ci serve? Ci serve:  char *prg; // to compile into a list char *p; // next token to parse.
20:28 Così noi ci portiamo avanti questo oggetto qui,  ce lo passiamo in giro per le nostre funzioni  
20:34 di parsing e abbiamo sempre l'inizio della stringa  che rappresenta il programma e, in questo caso, ci  
20:39 accontentiamo benissimo che sia terminato da NULL,  perché comunque dentro il nostro programma un byte  
20:45 a zero non si può avere, quindi ci sta benissimo  che le cose vadano così senza complicarci  
20:52 la vita con lunghezze e cose del genere. E qua invece char *p, next token to parse,  
21:02 dov'è che siamo arrivati col parsing. Quindi  noi questo qui praticamente all'inizio coincide  
21:07 con "prg", poi man mano che facciamo il  parsing andiamo avanti e così via. OK?
21:13 int main(int argc, char **argv) Dovremmo leggere praticamente un  
21:23 programma da un file. Guarda, all'inizio  facciamo una cosa, facciamola più facile:  
21:31 usiamo la funzione... cioè leggiamo una riga  praticamente direttamente dallo standard  
21:38 input. Cioè noi avviamo il nostro linguaggio di  programmazione, la gente ci scrive praticamente   con un piccolo prompt il programma, preme invio e  il programma viene eseguito, perché così il ciclo  
21:47 di sviluppo è più veloce. O forse ci incasiniamo  che ogni volta dobbiamo ripetere 'ste cose.
21:53 Guarda, facciamo una cosa. Invece diamo int  argc, char **argv. Così a noi ci arriva un  
22:02 array di stringhe che sono quelle date nella  linea di comando dal C. E quanti ne abbiamo? 
22:09 Primo... allora, quando già solo per il fatto  che io ho eseguito il programma, guardate,  
22:17 argv[0] è sempre il nome del mio programma  e argc è 1, quindi non può essere mai 0.
22:25 Compiliamo 'sto programma che non  funziona niente. Allora, prima di tutto: 
22:35 #include Ed è 1. 
22:42 #include
22:50 Eh, struct... str... qua "str" andava qui e  anche qui, che non è il nome della struttura,  
23:02 che la struttura qua nomi non ne ha.  In questo caso è proprio direttamente   la definizione di un membro. Noi non la  stiamo chiamando in nessun modo questa  
23:10 struttura perché ci serve solo una volta e  quindi non la chiameremo più. str... list...
23:18 First parameter of main... Scusate, qua  ho invertito stupidamente queste due cose.
23:29 Esatto. Guardate, quando io eseguo questo  programma, vedete, il nome del programma   è il primo argomento che viene passato al  programma stesso. Questo è utile perché a  
23:39 volte ci sono dei programmi che sono lo stesso  binario, ma in base a come vengono chiamati,  
23:44 cioè se lo chiami tipo "ls", fa una cosa, se  lo chiami con un altro nome fa un'altra cosa.  
23:50 In Unix è molto molto facile che accada ciò.  ls -l /usr/bin... Vediamo se qua ne trovo qualcuno  che è un link simbolico. wish... vi... view... 
24:04 Ecco, guardate, per esempio, se io controllo  dentro i binari qua di MacOS, guardate,  
24:12 ci sono diversi link simbolici. Per esempio, "vi"  è linkato a "vim", ma a volte può capitare che se  
24:22 il vim è chiamato tramite il suo link simbolico  "vi", e lui se ne accorge che il primo argomento è  
24:27 effettivamente "vi" e non "vim", cambia alcuni  comportamenti per avere una compatibilità  
24:33 più stretta con "vi". Non so se succeda, è  molto probabile che ciò accada, e così via. 
24:38 Quindi, comunque, questa cosa  è utile da sapere. Scusate.
24:46 ToyForth. Allora, facciamo una cosa. Noi vogliamo, tanto per iniziare,  
24:56 che... quindi if argc != 2 (che io c'ho  il nome del mio programma ToyForth e il  
25:07 file che voglio eseguire), diamo errore. fprintf... stderr... fprintf. E allora,  
25:14 fprintf è come la printf, ma ha un primo argomento  che gli specifica un oggetto FILE* dove puoi  
25:22 scrivere, e l'oggetto FILE* stderr, definito  direttamente dalla libreria standard, significa  
25:29 che voglio scrivere nello standard error. È sempre il terminale, ma il terminale ha   due canali, uno per l'output normale e uno  per lo standard error. In questo modo puoi  
25:38 praticamente catturare l'output di un programma  senza farti catturare gli errori, o viceversa. 
25:44 Quindi questa è una cosa utile e noi qua scriviamo  correttamente uno standard error come dovremmo: 
25:53 "Usage: %s filename\n", argv[0] ...così gli spieghiamo com'è che  
26:07 lo deve usare all'utente, che non  passa esattamente due argomenti. 
26:12 return 1. E ritorniamo un errore. Se ora compilo io 'sto robo qui, se lo  eseguo così mi dà errore. Se lo eseguo  
26:19 con un argomento non mi dà più errore. Il che bene... ciò che voglio fare è anche  
26:28 di caricare questo programma da qualche parte in  memoria, in un buffer, così poi posso chiamare la  
26:36 mia... boh, credo che si chiamerà compile. Quindi tfobj *prg = compile(prgtext),  
26:46 il testo del programma. E poi farò qualcosa come exec o  
26:53 eval... no, eval sarebbe, diciamo, l'unione  di compile ed exec. No, facciamo exec(prg).
27:02 Anzi, prima devo creare un contesto di  esecuzione. Esatto. Ci manca una struttura qua,  
27:11 perché noi qui abbiamo il parser, ma ci  serve una struttura che faccia da contesto,  
27:22 perché io voglio poter utilizzare più  interpreti nello stesso momento di ToyForth,  
27:27 e ognuno avrà il suo stack e ognuno avrà, non lo  so, quelle altre informazioni che possono servire.
27:33 Quindi typedef struct tfctx... questo è  il mio contesto di esecuzione... tfctx. 
27:42 E cos'è che avrà il mio contesto  di esecuzione? Avrà: tfobj *stack.  
27:49 Questo è lo stack principale. E poi avrà...  ce lo teniamo un riferimento al programma  
27:56 che stiamo eseguendo? Ma questa cosa la  vedremo dopo. Questa cosa la vedremo dopo,  
28:03 se vogliamo farlo o meno.  Però avremo il nostro compile.
28:10 Allora, ci serve anche un'altra cosa prima di  poter continuare. Siccome il nostro stack di  
28:15 fatto è un oggetto, un oggetto di tipo tfobj, ci  serve in realtà anche una funzione che ci crea un  
28:26 oggetto nuovo di ognuno di questi tipi. OK? Perché  io devo poter creare effettivamente un oggetto  
28:35 stack, devo poter creare un oggetto intero, devo  poter creare un oggetto del tipo che mi pare.
28:43 Quindi facciamo questa funzione qua. Allora,  
28:49 quindi queste sono le strutture.  Quindi qua facciamo un po' di   object... object related functions. E queste sono le mie data structures. 
29:13 Separiamo un po'. Qua vedo  un... OK, li avevo fatti giusti. 
29:26 Vabbè, questo è niente qua. Ma...  un po' di artigianato del software.
29:40 Allora, a me serve tfobj *createObject(int type). // Allocate and initialize a new Toy Forth object.
30:11 Una cosa molto importante: qua ce ne  fregheremo di gestire gli out of memory,  
30:19 però faremo una cosa, poi dobbiamo usare dei  wrapper. Allora, iniziamo subito a fare questa  
30:25 cosa qui. Ora ve lo faccio vedere. Allora, in questo caso io farò:  tfobj *o = malloc(sizeof(tfobj)); o->type = type; (che è l'unica cosa  
30:41 che mi passa qua il convento) o->refcount = 1; (quindi no,  
30:46 il conto referenze parte a uno perché lo sto  ritornando e qualcuno lo assegnerà da qualche  
30:52 parte a una variabile. Per cui effettivamente  io qui parto col reference counting settato).
30:59 Però siccome poi ho il problema che dovrei  cercare sempre di controllare se malloc  
31:05 eccetera eccetera, ma io in realtà  voglio quittare con "out of memory",   quindi lo chiamo xmalloc. E qua  faccio: Allocation wrappers. 
31:25 E scrivo, guardate, mi vado a prendere  il prototipo della malloc, che va bene.  
31:34 Semplicissimo, ma il punto è che io voglio  che la mia xmalloc sia esattamente uguale,  
31:41 solo che farà questa cosa qua: void *ptr = malloc(size); 
31:47 Esattamente. Noi chiamiamo la  malloc. Se il puntatore è NULL: 
31:53 fprintf(stderr, "Out of memory  allocating %zu bytes\n", size); 
32:08 exit(1); La exit è una chiamata di sistema definita   in unistd.h. Quindi andiamo a mettere questa cosa  qua. Altrimenti ritorniamo il nostro puntatore.
32:22 Allora, questa è una versione di malloc  che semplicemente va in panico quando non  
32:31 c'è abbastanza memoria. Poi noi avremo pure  realloc, che mi sa che non ho mai spiegato,   ma la useremo molto all'interno di  questo programma e la devo spiegare. Sì.
32:43 Allora, faccio una precisazione.  Siccome io questo programma qui che   sto scrivendo non me l'ero preparato,  perché sennò non c'è bello, è finito,  
32:50 diciamo, la parte di apprendimento di  tutte 'ste robe qui. Perché se non vado   in difficoltà io stesso nel pensare a come  devo fare le cose, il valore didattico di  
33:01 questa lezione sarebbe veramente basso.  Quindi non è detto che noi finiremo per   usare veramente le strutture nelle prossime  lezioni che io qua sto definendo. Si vedrà.
33:11 Però ora c'abbiamo createObject e quello  che possiamo fare è che poi comunque  
33:17 dobbiamo avere altre funzioni. Per esempio: createStringObject(char *s, size_t len). 
33:28 Anzi qua, invece di "pointer" chiamiamo "s"  perché è la stringa. E questa funzione qui farà: 
33:35 tfobj *o = createObject(TFOBJ_TYPE_STR); Come si chiama? ptr, sì. 
33:57 o->str.ptr = s; o->str.len = len; 
34:03 Allora, qua stiamo andando a settare noi,  visto che la nostra struttura ha questa   union e ognuno di questi elementi della union  sarà utilizzato da un tipo diverso. Il tipo  
34:13 stringa utilizza ovviamente questo "str" qui,  questa struttura dove viene settato l'inizio  
34:20 della stringa, il puntatore dove inizia  la stringa, e la lunghezza della stringa.
34:27 E fin qui mi pare che ci  siamo. Poi a me mi serve pure:  tfobj *createIntObject(int i). E qui quello che farò è... vabbè,  
34:43 questo me lo copio. Poi siccome... ah,   qua return o. E anche qua return o. Se  non lo ritorno non ho fatto un bel niente. 
34:53 Qui il tipo è intero. Qui quello  che setto è o->i = i. Return o.
35:08 Facciamo a questo punto tutti gli altri.  Quindi qua abbiamo string, il booleano,  
35:16 che praticamente è uguale all'intero, né più  e né meno, però lo dobbiamo creare lo stesso,  
35:28 perché cambia questo, il tipo,  e ciò è molto importante. 
35:38 Il simbolo pure, che è praticamente  identico all'oggetto stringa.
35:46 Qui possiamo fare una cosa: tfobj *createSymbolObject(char *s, size_t len). 
35:59 Potrebbe avere senso qua fare: tfobj *o = createStringObject(s, len); 
36:05 perché sono uguali. È l'unica cosa  che cambia: il tipo. E qui il tipo   lo settiamo a TFOBJ_TYPE_SYMBOL. Scusate. Esatto. Questo è un trucco per non ripetere la logica e il  
36:18 codice. Se poi domani cambieremo ptr e len qui,  non lo dobbiamo cambiare anche per il simbolo.
36:25 Qui in teoria noi dovremmo mettere anche  dei commenti, però siccome qua è troppo   ovvio effettivamente quello che sta succedendo in  queste funzioni, neanche lo mettiamo qua. Quello  
36:35 che dovrei... io quello che farei in questo  caso è mettere qui un commento in cui dico: 
36:43 "The following functions allocate Toy  Forth objects of different types." 
36:57 Scriviamo così. Poi magari questa  roba qui si potrà estendere,   però finora è troppo semplice  per mettere altri commenti.
37:07 E poi che abbiamo? La mia lista. Sì, la mia lista. createListObject(). 
37:20 Di tipo lista. E qua ci siamo. o->list. (L'ho chiamato 'ele'.) 
37:31 o->list.ele = NULL; (perché all'inizio è vuota) o->list.len = 0; (perché all'inizio è vuota) 
37:43 Return o. Vediamo se compila ancora 'sto robo. Figurarsi. Perché ho scritto ciò? OK. 
38:03 refcount... No member refcount. Ci manca una 'n'. Compiliamo. 
38:12 Non-void function non ritorna una fava... return o. 
38:21 Compiliamo. Eh vabbè, la   funzione compile non esiste, la funzione exec non  esiste... ma poi le riempiremo con calma. Va bene?
38:33 Credo che questa lezione è andata  già abbastanza lunga. Chi volesse,  
38:38 perché no, si potrebbe lanciare già a  implementare 'sta roba qui. Potrebbe   essere comunque una cosa interessante da  fare. Se ancora non vi sentite pronti,  
38:48 guarderete la prossima lezione,  la prossima settimana, e man mano,   quando vi sentite pronti, a un certo punto vi  sganciate dalle lezioni, andate in una scoperta,  
38:57 implementate da soli ToyForth e poi tornate qui e  vedete mano mano come lo implemento io. Ciao raga.

