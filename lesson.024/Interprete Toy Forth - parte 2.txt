Eccoci qua ragazzi, dobbiamo continuare il nostro  Toy Fort. Io l'ho aperto poco fa per ricordarmi  
che cos'è che avevamo fatto. Vabbè, ma avevamo  fatto poco, poco, ma tanto concettualmente. 
Questo è il nostro oggetto. Noi quando abbiamo  a che fare con un linguaggio di programmazione   interpretato e stiamo scrivendo un interprete,  questa è una struttura dati assolutamente  
necessaria, perché dobbiamo rappresentare sia gli  elementi del nostro linguaggio di programmazione,  
eh, gli elementi, diciamo, anche sintattici.  Quando facciamo il parsing noi utilizzeremo  
sempre questo oggetto per rappresentare i  vari pezzi del programma, ma anche ovviamente  
ancor di più. Perché? Perché questa cosa  è specialmente vera nel nostro linguaggio   di programmazione, che è rappresentato  da una lista di, diciamo, di oggetti,  
ma in altri linguaggi di programmazione potrebbe  non essere così e potremmo compilare in byte code. 
Quindi sintatticamente, eh, il programma  non verrà convertito poi, diciamo,  
in oggetti di questo tipo, ma comunque lo stato  di esecuzione, quello che c'è dentro le variabili,   quello che c'è dentro lo stack e così via,  sarà comunque un oggetto di vari tipi. 
Quindi se voi aprite i codici  sorgenti di Ruby, di Python,   troverete qualcosa di del genere. Eh, ma oltre a questa struttura avevamo  
altro. Avevamo un parser. Questo è molto  comodo perché poi vedrete che nel parsing,   siccome c'è sempre da parte delle funzioni  che fanno il parsing di ritornare dov'è che  
siamo arrivati a fare il parsing dentro la  stringa che rappresenta il nostro programma.  Eh, e allora ogni volta o praticamente passi  un puntatore, un puntatore, un puntatore,  
quindi ti scrive poi in questo puntatore di  puntatore dove è arrivato il puntatore originale,  
o te lo ritorna come valore la funzione di  ritorno dov'è che siamo arrivati, ma è scomodo.  In questo modo noi passiamo un puntatore  al nostro tipo TF parser e, eh, usiamo  
praticamente questa P per avanzare e abbiamo  anche un riferimento all'inizio del programma. 
Poi possiamo scrivere qui, per esempio,  la linea di codice dove siamo arrivati e   anche nel nostro oggetto possiamo aggiungere la  linea di codice in cui quell'oggetto è stato,  
eh, trovato, così quando ci sono errori di  sintassi, o meglio, quando ci sono errori a  
runtime oltre a quelli di sintassi. Qua la linea di codice ci serve per   segnalare dov'erano gli errori  di sintassi, tipo la linea 14. 
Se aggiungiamo poi 'line' qua, tipo int line,  ma lo faremo magari dopo se ci arriviamo, eh,  
possiamo anche, eh, segnalare gli errori a  runtime dicendo dov'è che è avvenuto l'errore,  
in quale linea è avvenuto l'errore, il  che ovviamente è effettivamente comodo.  E poi qua abbiamo il contesto di  esecuzione che nel caso di questo  
semplice Fort giocattolo utilizza solo uno stack. Qualcuno mi ha chiesto: "Ma perché lo stack lo  
rappresenti con lo stesso tipo, eh, che usi,  diciamo, per le liste del linguaggio stesso?" Beh,  
per semplicità. "E perché le liste del linguaggio  le, eh, le implementi utilizzando un array?" 
Eh, allora la linked list può sembrare per  questo caso d'uso la cosa ideale. In realtà  
non lo è in una implementazione seria e vi dico  perché: la linked list è interessante perché ha  
comunque una complessità costante, cioè O di uno,  sia per inserire elementi che per rimuoverli. 
Quindi io non devo fare nessun lavoro sugli  altri elementi quando ne aggiungo uno,   quando ne prendo uno. Sono allocazioni  a sé collegate dai puntatori next  
o previous se è doppiamente linkata e così via,  ma in realtà ha una cattiva località della cache e  
quindi, e inoltre, usa un sacco di memoria perché  ogni nodo ha un puntatore al next e così via,  
e quindi c'è un sacco di memoria che si spreca. Eh, la, poi c'è l'overhead dell'allocazione  
stessa di ogni pezzo di malloc che deve  avere dei metadati e così via. Ci sono vari  
motivi per cui, eh, non è proprio l'ideale. In realtà qui potrebbe sembrare che c'è il  
problema che ogni volta che la nostra lista  cresce, che noi la usiamo pure per stack,  
ma lista, stack e array non è tanto il nome,  ma è proprio la struttura dati che modella. 
Eh, allora da questo punto di vista c'è  una distinzione interessante da fare. Un   conto è come chiama una data struttura dati, un  linguaggio di programmazione ad alto livello,  
e che operazioni sono definite in quella struttura  dati. Un altro conto è il modo in cui è poi in C  
implementata, perché anche assicurandogli  la stessa complessità, eh, algoritmica per  
le stesse operazioni, ci sono diverse operazioni,  diverse implementazioni possibili e anche diverse  
implementazioni poi comunque possono  avere diverse complessità algoritmiche.  Quindi un conto è l'alto livello,  la descrizione che fa per esempio,  
non lo so, Python di una struttura dati,  un conto è poi quello che succede sotto.  Ovviamente se sai quello che succede sotto  puoi usare meglio la struttura dati. Eh,  
ma qua la cosa interessante è questa. Se noi oltre ad avere la lunghezza e   l'array del numero degli elementi avessimo  anche size_t alloc_len, possiamo sovraallocare 
questa lista, perché se vediamo che inizia  a crescere, per esempio partiamo quando una   lista è vuota, l'allochiamo a quattro elementi. Quando poi arriviamo al quarto elemento e c'è da  
inserire il quinto, facciamo una realloc. Realloc  praticamente crea una nuova allocazione con più  
spazio, quindi se è necessario copia anche  i dati che avevamo prima, e qui c'è anche  
l'inefficienza potenziale della rialloc. Eh, dopo che è arrivata a quattro elementi,  
noi ne possiamo aggiungere otto, poi ne  possiamo aggiungere 16 e ci ricordiamo  
quanto è grande l'allocazione in maniera  disgiunta da quanti elementi ci sono   davvero in quel momento nella struttura dati. In questo modo, allocando ogni volta per, eh,  
potenze di due e quando gli elementi invece  decrescono non deallocando, quindi lasciandoci  
sempre lo spazio per il massimo stack che abbiamo  visto, si dice che la amortized time complexity  
della struttura dati, quindi la complessità  ammortizzata, a quel punto è costante, quindi  
rimane O di uno come se fosse una linked list. Perché è vero che a volte io devo fare delle   operazioni molto costose di riallocazione, ma  è anche vero che queste operazioni le faccio  
sempre con meno frequenza, visto che ogni  volta alloco per la potenza successiva di 2,  
e quindi praticamente finisce che la mia  complessità è uguale a quella della linked list,   ma ho due vantaggi fondamentali: uno, la località  maggiore e, secondo, che è enorme, impagabile: 
il fatto che io posso accedere in tempo costante  all'elemento i-imo, quindi io praticamente posso  
accedere in maniera casuale alla struttura dati,  e un array di un linguaggio di programmazione deve  
consentire questo accesso in maniera non lineare. Se fosse O di N, eh, quindi in tempo lineare,  
l'accesso all'n-esimo elemento, dei  programmi semplicissimi che sulla  
carta sembrano non avere niente che non vada,  diventano quadratici nella loro complessità. 
Anche un ciclo for che accede prima  all'elemento 1, poi 2, poi 3, poi 4,  
diventa un programma di complessità quadratica. Quindi questo è il fatto, ma noi per ora ce ne  
freghiamo anche di questo e faremo una cosa  banalissima di riallocazione se è necessario,  
eh, ogni volta, perché siamo qua non per fare  il linguaggio di programmazione più efficiente,  
ma per fare un giocattolo che  sia però semplice da capire.  Quindi è questo che avevamo. Poi qua avevamo  creato una funzione che crea un oggetto e la  
usavamo poi in maniera specializzata  per creare oggetti di vario tipo:  
simbolo, int, boolean e così via. Lista. Qua c'è un errore però, perché questo 'i' non  
viene usato mai. Me ne sono accorto poco fa. Quindi questo è void. Quando creo un oggetto  
lista io lo creo vuoto e poi saranno le altre  operazioni che farò sulle liste che mi consentono  
di aggiungere elementi sulla lista o accedere  all'elemento n-esimo della lista e così via. 
E poi 'sto programma non faceva  niente, neanche compilava,   perché qua uso una compile che in realtà è  poi un exec che non sono neanche definiti. 
E qua gli davo Program text, che è Program Text,   che in realtà è argv[1], esatto, che è  il primo argomento della mia... Ah, no,  
devo... abbiamo detto che volevamo leggere  questo programma da un file, quindi, eh,  
qua che abbiamo incluso STDIO ce l'abbiamo. FILE *fp = fopen(argv[1], "r");  
Apriamo il file in read-only. E poi possiamo  magari vedere quanto è grande il file. 
Eh, ci sono due trucchi per fare. Possiamo fare  fseek alla fine del file e poi usare ftell per  
vedere cosa ci ha dato, se vogliamo farlo in  maniera completamente portatile, eh, soltanto  
usando la Lib C, senza utilizzare nessuna roba  di Unix Standard, perché se... Sì, perché questo  
ovviamente sarebbe una API di Unix, proviamo  a usare questa tecnica che si usava una volta. 
Non ci dimentichiamo poi di chiudere il file. Allora, guardate, se io faccio fseek. fseek  
cambia il cursore di dove stiamo  leggendo in questo momento nel file. 
Io posso andare per esempio alla fine del file  fseek, offset e dove. Quindi guardate io che  
faccio. È f... iso... SEEK. 
fseek 0, quindi dico "vai alla posizione zero  a partire dalla fine del file" e siccome poi  
io c'ho una funzione che si chiama ftell che  mi dice dov'è che sono arrivato, ed è un long, 
io in questo modo so quant'è grande il  file. Vediamo se è vero. source file size 
%ld file size. compile ed exec li  commentiamo, sennò qui non si compila niente. 
Eh, program.toy 5 dup * print. Sono 14 byte, è vero. Sì, 14 byte written qui.  
Quindi questo è un modo completamente portatile, portabile, forse dovrei dire, per avere la  
dimensione del file. A questo punto, che  me ne faccio della mia dimensione del file? 
Eh, program text. char *prgtext =  xmalloc. Avevamo qua, vero? L'avevamo  
fatta. xmalloc(file_size +  1) perché ci serve anche il   null term. E poi facciamo fread. f... no, fread. Che argomenti ha?  
Puntatore, dimensione, numero di  item, stream. Quindi puntatore, 
dimensione, numero di item e lo stream. Vabbè,  qua dovremmo controllare che in effetti, eh,  
leggiamo tutto il file, in realtà ce ne fottiamo  per quel discorso della semplicità che dicevamo. 
Alla fine però prgtext[file_size] = 0. Dobbiamo  mettere il null term, perché finora abbiamo  
letto dal byte 0 al byte file_size - 1,  ma qua ne avevamo allocato uno in più. 
Siccome è zero-based, ovviamente, file_size  perché parte da zero gli indici degli array,   quindi file_size sarà l'ultimo byte di questa  allocazione qua e facciamo il null term. 
A questo punto questo lo cancelliamo e qua  scriviamo prgtext e prg_text. Qua dovremmo  
avere il nostro programma eh, program. 
E invece no. E vi dico perché. Dopo che noi  abbiamo fatto praticamente fseek all'end,  
ovviamente poi fread parte da leggere  dalla fine del file e non c'è più niente. 
Poi dobbiamo fare di nuovo un fseek(fp,  0, SEEK...). Quindi vogliamo che il file  
si riposizioni il cursore all'indice  zero a partire dall'inizio del file. 
SEEK_BEGIN, com'è che si chiama? Perché si...  START non me lo colora? SEEK_SET, scusate. 
Ok, ricompiliamo. Eh, esattamente. Program  text: 5 dup... Eh, e poi c'è il new line,  
perché alla fine del programma c'è il new line  e siccome poi io ho messo anche il new line qui,  
qui ce ne sono due e vediamo che il  cursore, cioè che c'è una linea vuota.  Ma va bene così, perché noi vogliamo per  il parsing prendere tutto il programma,  
non è che vogliamo fare qua nessuna operazione  di cleanup della stringa in questo momento.  Piuttosto, se volete osservare meglio questa  cosa qua, mettiamo due parentesi quotate,  
ovviamente, così quando ci stampa il programma,  ecco, si vede che parte da qui il programma,  
dalla virgoletta, poi c'è il new line e poi  si chiude qua, si capisce che c'è il new line. 
Ma in realtà noi non vogliamo neanche stampare  'sta roba. Invece qui vogliamo scrivere,  
allora, if (fp == NULL). Qua un errore,  se il file non c'è lo dobbiamo mettere. 
Opening Toy Fort program. return 1. Qua diamo questo errore. perror...  
ridefinita in STDIO.H, quindi non dobbiamo  includere niente. E qua mettiamo un commento. 
Read program for later parsing. Ok, ora la nostra funzione compile. Per ora  
exec la commentiamo. La nostra funzione compile. Turn program into Toy list. 
Non è una vera compilazione in realtà, ma  chiamiamola così perché poi forse possiamo  
fare anche delle operazioni che potrebbero  somigliare un po' alla compilazione.  Ehm, eh, perché vi dico una  cosa. Voi, vi avevo fatto vedere 
com'è che funziona questo linguaggio  qua. Eh, poi questi linguaggi qua  
sono una famiglia di linguaggi chiamati  concatenativi. Il più interessante... 
Joy Programming Language. Linguaggio  di programmazione Joy. Come vedete,   guardate, 'square' qua definisce  'square' che è 'dup' e forse il  
punto dice che è finita questa definizione.  In questo caso è un linguaggio concatenativo  molto interessante con delle robe funzionali,  
addirittura le closure, la ricorsione. Questo  è Qort, guardate com'è semplice, è pazzesco. 
Eh, molto, molto interessante. Ora io avevo  partecipato un po' a questo linguaggio di  
programmazione e avevo proposto una  modifica a questi linguaggi basati   sullo stack che poi comunque credo che  sia apparsa poi negli anni... in Antirez. 
Esiste 'sta roba ancora? Sì, io qua avevo  implementato, guardate ragazzi questa foto,  
questa foto me la salvo. "A Joy implementation  written in...". Questo l'avevo fatto io nel 2004. 
Questa implementazione credo che  implementasse già il variable capturing. 
Ah, guardate qua, infatti, guardate cosa mi  avevano scritto in questo wiki Manfred: "Se puoi  
leggere questo, Salvatore, ti interesserebbe  scrivere una, diciamo, dare un contributo  
al paper che stiamo scrivendo sui linguaggi  concatenativi. La tua implementazione sembra  
significativamente differente dalle altre e il  tuo contributo in questo paper sarebbe benvenuto." 
Non so se poi io ho risposto, forse in parte sì. Comunque, praticamente, qual è la differenza che  
c'è in questa implementazione che avevo fatto  io? C'è un modo di implementare le variabili  
locali in questi linguaggi senza violare le  caratteristiche semantiche del linguaggio. 
Vi faccio un esempio. Questo è un  programma, perché poi questa cosa  
qui la implementeremo noi nel nostro Toy Fort. Questo è un programma che fa '5 dup *', quindi  
cinque si duplica. Quindi questo è lo stack.  Vi ricordo come funzionava molto brevemente:  
arriviamo, vediamo cinque, mettiamo cinque  nello stack. 'dup' e lo duplichiamo. '*' (per):  
preleviamo questi due dallo stack, li  moltiplichiamo e mettiamo il risultato,   eh, sullo stack. 'print': preleviamo 25, lo  stampiamo a video. Questo è il nostro output. 
Ok? E i linguaggi sono tutti così, senza  variabili, i linguaggi basati sullo stack. 
Ma io avevo pensato: e se noi utilizzassimo  un tipo che si chiama tupla, che è tipo una  
lista così, e quando ci sono queste tuple,  in realtà noi catturiamo delle variabili  
locali in dei simboli A e B? Quindi, per esempio, guardate,   io c'ho 5 e qui, eh, scrivo questo e  quindi 5 sarà catturato dal mio simbolo A. 
Quindi nello stack avevo 5 e lo... faccio il  push... lo stack. Poi qua c'è una cattura di  
una variabile, lo prendo e ora questo  cinque sarà... quindi ora c'ho pure   delle variabili locali, a = 5. Poi posso scrivere $a $a che  
fa il push della variabile locale sullo  stack, quindi 5, e ho implementato 'dup'. 
Ma siccome queste variabili qua non cambiano  nulla dal punto di vista semantico del linguaggio,  
rendono scrivere una quantità di  programmi molto, ma molto più semplice.  Questa mia implementazione del 2004  aveva questa modifica, ma vi faccio  
anche un altro esempio. Per esempio 5 10. Un altro comando tipico dei linguaggi, eh,  
di programmazione stack-based è 'swap', che se qua  c'abbiamo 5 e 10, il risultato è 10, 5. Invertono,  
perché spesso devi fare questa meccanica. Se avete programmato, per esempio, in Lua,   implementando in Lua della roba in C, dei  programmi in C, Lua ha un'interfaccia basata  
sullo stack che ha di queste complessità. Alla fine le cose diventano un po' scomode  
e allora, per esempio, come diventa 'swap'?  L'implementazione di 'swap' è tutta naturale,  
non devi neanche implementare queste primitive  qui nel linguaggio, perché puoi implementare  
'swap' in questi termini: [a, b]. Ok? Poi vi farò vedere che questa roba qui rende  
i linguaggi molto più semplici da utilizzare,  molto più maneggevoli dal punto di vista  
dell'utente finale, e quindi noi potremo finire  per avere qua in Toy una compilazione di queste  
variabili e poi assegnare a queste variabili,  per esempio, un indice unico e così via.  Questo, diciamo che è una specie di, eh, diciamo,  precompilazione, compilazione in byte code,  
perché comunque non interpretiamo ogni volta  il sorgente mano a mano che a runtime facciamo  
eseguire il programma, ma c'è qualche fase  iniziale in cui, per esempio, a delle variabili   simboliche possono essere associati degli  indici fissi in una tabella di variabili locali. 
Ma torniamo indietro a questa digressione.  Il mio programma compile era... eh,  
tfobj*. Ritorna 'compile(char *prg)'. L'idea è questa: e in realtà quello  
che fa compile non è altro che  trasformare una stringa in una lista. 
E per fare questa operazione qui  io devo implementare un parser. I  
parser di solito si scrivono... quando uno  vuole imparare qualcosa li scrive a mano. 
Quando invece vuole fare una cosa al  volo, che non è però tanto importante,   magari utilizza un generatore di parser. Quando poi le cose si fanno davvero serie, devi  
scrivere un'implementazione seria di un linguaggio  di programmazione serio, utilizzi di nuovo il  
parser scritto a mano. Questa è la logica. È  fondamentale imparare a scrivere un parser a mano. 
Allora, siccome ora già siamo andati lunghi,  iniziamo solo con la prima parte del parser.  Allora, io per iniziare voglio... voglio  creare un oggetto di parsing che era TF Parser. 
TF Parser parser. parser.prg, eh, com'è che si  chiamano i campi? PRG e P. parser.prg = prg; 
parser.p = prg. All'inizio noi siamo sempre...  partiamo ovviamente dall'inizio del programma  
che è il puntatore che ci hanno passato. Allora, qui io non mi metto a fare delle funzioni   per costruire un parser e inizializzarlo.  Lo alloco nello stack qua brutalmente,  
praticamente lo inizializzo così, e poi  passerò alla mia funzione di parsing il parser,   in questo modo, parser, il puntatore al parser. E per esempio, io per iniziare devo scrivere while  
(parser.p[0])... fino a quando, quindi,  non ho incontrato il terminatore null. 
Allora, la prima cosa che devo fare è consumare  gli spazi vuoti, quindi... parseSpaces(&parser). 
Vabbè, guarda, il parsing lo mettiamo  sempre dentro questa... stanza,   diciamo. void parseSpaces(tfparser *parser) p chiamiamolo. Ah, m vabbè, chiamiamolo  
'parser'... è troppo lungo, però  'p' poi viene p.p... perché il   campo si chiama pure .p e pare male. Allora, io per consumare praticamente  
quello che c'è qui di spazi posso usare include ctype.h. 'isspace'. La funzione, eh, fa tab,  
new line, spazi, ok. Mi piace. E  quindi questa funzione che farà? 
while (isspace(parser->p[0])) parser->p++;  incrementando il puntatore fino a quando il  
carattere su cui sono ora, quindi  [0], è uno spazio, incremento  
il puntatore e vado al prossimo carattere. Non so se sto facendo bene. Poi qua facciamo  
una switch: switch (parser->p[0]). Quindi  se il carattere dove sono in questo momento  
è per esempio un numero... Ah, qua dovrei  verificare... no, non mi piace la switch.  
In questo caso noi usiamo if... if (parser->p[0])... if isnumber... 
isnumber... Sì, mi copre  esattamente... Ah, isdigit. 
Facciamo isdigit. Se è p[0] è  effettivamente un numero or parser->p[0] 
è il meno, perché un numero può  iniziare per il segno meno. parse... no 
parseInteger, parseNumber, perché poi  vediamo questi numeri com'è che li abbiamo  
rappresentati. Abbiamo solo gli interi, vero?  Sì, non abbiamo neanche i numeri... vabbè,   chi se ne frega. parseNumber(&parser). Allora, questo lo chiamiamo parseSpaces  
perché dobbiamo avere dei nomi che hanno  senso. parseNumber. Ma questo parseNumber  
a me mi deve ritornare effettivamente... Allora, qui io ho bisogno di un tfobj *o;  
l'oggetto che sto parsando. o =  parseNumber(...); eccetera eccetera. 
E se 'o' è NULL, perché il numero è formato in  maniera scorretta, io qui devo generare un errore. 
Sì. Allora, tanto per iniziare qua,  facciamo una cosa. Dopo che ho fatto   il parsing degli spazi, if (parser->p[0] p[0] == 0) break. Qua ho finito di compilare  
perché sono arrivato al null term of program. 
Qua mettiamo subito else, perché se  trovo qualcosa che non è valido nel   mio linguaggio di programmazione, qua settiamo  'o' = NULL, così come mi ritornerà NULL anche  
parseNumber se c'è un errore. In questo modo io qua faccio:  
check if the current token produced compilation error. 
Eh, if (o == NULL), allora io scriverò  magari printf("syntax error near..."), eh,  
massimo non lo so quanto gli metto. 32 caratteri e qua i puntini... e, eh, parser->p è dove sono  
arrivato... quella combinazione, diciamo. Qua c'è  stato un errore da qualche parte vicino a qui,  
che però in realtà sarebbe interessante non  dare p... perché p è a metà di un numero dove  
noi abbiamo trovato un carattere sbagliato. Sarebbe interessante dare l'inizio del   numero. Quindi qua potrebbe essere  più carino per esempio fare char  
*token_start = parser->p; e qua token_start. Vedete come la programmazione è tanto il  
processo anche di anticipare certi casini  o certe parti poco interessanti del nostro  
programma. E qua facciamo return NULL, ma  in realtà qua dobbiamo fare il cleanup.  Allora, questi oggetti che noi di cui facciamo il  parse devono finire però dentro una lista. tfobj  
*parsed = ... com'è? createListObject(). Questo era void perché all'inizio mi  
crea una lista vuota. Quando poi praticamente   io faccio il parsing di questo numero qua e  ce l'ho dentro il puntatore 'o', poi io...  
quando... se o == NULL c'è un syntax error. Else, io devo fare, eh, listPush() che non  
l'ho ancora scritta, parsed, che è il mio  oggetto lista, o. Quindi devo accodare 
alla mia lista questo nuovo  oggetto. Implementiamo listPush. 
list object. A questo punto,  
visto che le cose si mettono in questo verso,  le cose dell'oggetto lista buttiamole qua. 
Sì, anche la creazione, eh. void  listPush(tfobj *l, tfobj *ele) 
push the new... add the new element  at the end of the list 'list'. 
Allora l->... Anzi, qua  com'è che siamo messi qui? L, 
chiamiamolo L. Questo... realloc...  la grandezza di un puntatore. 
Io qua ho un array di puntatori,  quindi quanto deve essere grande   'sta allocazione? La dimensione di 'sto  puntatore, di cui io ho tanti elementi,  
per... scusate, ho toccato più volte il  microfono facendo credo un cattivo rumore   che poi non potrò togliere mai... per len  + 1, perché devo aggiungere un elemento.  
Quindi faccio questa riallocazione. l->list.ele[l->list.len] = ele; 
Ma qua c'è un discorso molto, molto,  molto, molto, molto importante. 
Ora io in questa lista c'ho una  nuova referenza di questo oggetto,  
quindi io dovrei fare inc_ref_count(ele),  dove aumentare il conto delle referenze. 
E secondo me è giusto che  sia così, che questa funzione 
increment the reference  count of the added element. 
Ci sono due scelte possibili. O il conto  della referenza lo gestisce listPush,   o altrimenti uno dopo che fa il  push nella lista lo fa a mano. 
Guarda, facciamolo a mano, perché sennò nel caso  del... ci sono vantaggi e svantaggi, poi vediamo. 
Guardate, in questo caso io per ora  questo lo tolgo, anche perché così   lo possiamo non implementarlo per ora. Per dire, qua se lo avesse gestito lui,  
poi io qua dovevo fare dec... o, perché altrimenti qua diventava  
due il conteggio. Ma io ora non ci faccio niente  con questo oggetto 'o' che già ha referenza uno,  
perché quando io creo gli oggetti, vi ricordo che  li creo con reference counting di uno, vedete qui? 
E quindi, eh, certe volte è comodo, certe  volte è scomodo. Niente, facciamo che:  
it is up to the caller to increment the reference  count of the element added to the list if needed. 
Questo è molto importante. Qua ci deve  essere scritto, una documentazione,   una funzione che non se ne occupa lei. E poi  l->list.len++; abbiamo un elemento in più. 
Allora, qua guardate che abbiamo fatto. Abbiamo  riallocato... ah, e realloc ovviamente prende  
prima list.ele... il vecchio puntatore. Guardate realloc. Realloc è come malloc,  
ma in realtà prende un'allocazione  precedentemente fatta e la modifica affinché  
sia la nuova dimensione che ci serve, d'accordo? E se necessario il puntatore può cambiare,  
quindi, ma i dati vecchi noi non  li perdiamo, vengono copiati. 
Se l->list.ele è NULL, come all'inizio, realloc  equivale a malloc, quindi è comodissima,  
perché prima era un puntatore NULL, quindi  diciamo a realloc noi non ce l'avevamo prima   un'allocazione, semplicemente vogliamo  un'allocazione di questa dimensione qua. 
All'inizio len è 0, quindi diventerà  len + 1 lo spazio per uno solo,   list.ele[0]... e quindi siccome però  gli indici partono da zero riempiremo  
il primo elemento e poi aumentiamo  la dimensione della nostra lista. 
Quindi ora abbiamo questo listPush che  usiamo qui, e dec_ref_count non ci serve più. 
Questa, la gestione ancora del ref counting  non l'abbiamo neanche implementata. 
Quindi quello che dovremmo fare ora  in realtà è implementare parseNumber.  Allora, se io provo a compilare questo programma  che succede ora? Ovviamente ho una quantità enorme  
di problemi, quindi linea 111... 'parser'  che avevo sbagliato, 'tfobj' scritto male, 
parseNumber non esiste. unused variable... e questa  
variabile qui non la uso mai. Tutto vero? Ora quello che faremo nella prossima  
puntata è implementare parseNumber. Allora, tfobj *parseNumber, vediamo  
dove arriviamo. (tfparser *parser)... perché  secondo me l'attenzione fra un po' crolla a zero,  
perché non mi ricordo da quant'è che  registro, ma è un tempo significativo. 
Allora, guardate qua che cos'è che  noi dobbiamo fare. Tanto per iniziare,  
vabbè, l'oggetto lo creiamo alla fine. Dobbiamo, tanto per iniziare, avere  
idea di dove comincia, di dove finisce il nostro  numero. Guarda qua, facciamo un buffer, non lo so,  
di 128 caratteri al massimo e poi facciamo che fino a quando... parser->p[0]...  
while isdigit... fino a quando è un carattere e questo qui dovrebbe anche includere il fatto  
che se arriviamo alla fine del programma...  però noi mettiamo un esplicito. parser... 
->p[0], cioè non è 0, il byte 0, NULL terminator,  è un carattere. Facciamo che int i = 0. Copiamo  
dentro questo buffer che noi stiamo scrivendo. buffer[i] = parser->p[0]... Mh. No,  
c'è un modo che mi piace secondo me di più.  Invece facciamo che char *start = parser->p; 
Ok. Sì, parser->p, scusate. Char... semplicemente fino a quando soddisfa  
i nostri criteri di quello che  ci può stare dentro un numero. 
E allora il meno può apparire solo all'inizio,  quindi if (parser->p[0] == '-') parser->p++; 
e qua parser->p++;   Quindi questo lo gestiamo come caso a parte  perché il meno può apparire solo all'inizio. 
Incrementiamo il nostro parser. Quando  abbiamo finito 'sto ciclo, end = parser->p. 
E questo 'end' in realtà è il primo  carattere che non è tra i caratteri  
numerici che noi gestiamo. Quindi int numlen è uguale a end... Allora, i puntatori,  
siccome sono numeri, si possono sottrarre  senza problemi per vedere qual è la differenza,  
perché io c'ho l'indirizzo di memoria di  dove parte il numero, che è questo parser->p.  Poi parser->p, mentre continuo a  incrementarlo, parser->p++ qui.  
Quindi alla fine la sottrazione ci dirà quanti  caratteri ci sono là dentro questo numero. Ok? 
end - start. A questo punto if  (numlen >= 128) return NULL. 
Questo è la lunghezza massima del mio numero.  Vabbè, qua facciamo #define MAX_NUM_LEN 128,  
MAX_NUM_LEN, 128 e MAX_NUM_LEN. Così se lo vogliamo cambiare in  
futuro è più facile, non è hardcoded,  anche se questo è un piccolo esempio,  
ma comunque un minimo di decenza  la possiamo anche, diciamo, tenere.  A questo punto che siamo qua e sappiamo che  abbiamo meno di 128 byte o meno di MAX_NUM_LEN,  
copiamo dentro buffer a partire da start il numero  di caratteri di cui è composto il nostro numero e  
mettiamo il null term, il terminatore null. 
E a questo punto possiamo usare una  chiamata di sistema che si chiama 
str... ma guardate, ne uso una terribile che  si chiama atoi() e me ne frego. Guardate,  
ritorna un intero partendo dalla stringa,  perché qua dobbiamo fare cose facili. 
A questo punto posso finalmente  creare il mio oggetto 
e lo creo dandogli come numero  atoi(buff) e ritorno il mio oggetto. 
Ok, questo mi dovrebbe tornare un  oggetto numerico che effettivamente  
è quello che io voglio. createIntObject. 
Se ora compilo questo programma qui, non  abbiamo memcpy perché includiamo string.h. 
Qua dobbiamo ritornare il nostro  parsed, il nostro programma già parsato. 
E qua questa variabile non è utilizzata,  ma noi troviamo un modo di utilizzarla.  
La nostra exec la facciamo  diventare una cosa molto più facile. 
Qua mancava uno spazio. Execute the program.  In realtà noi la nostra exec, che però non la  
vogliamo assolutamente implementare, eh, tfobj *prg, 
gli facciamo semplicemente stampare  quello che c'è dentro. Eh, for... int... 
prg->list.len... j++... e poi in base al tipo stampiamo quello che c'è  
dentro. Vabbè, prima siccome questo, il programma,  è una lista, apriamo la parentesi quadra e la  
chiudiamo. E qua ci mettiamo anche un new line. Ehm, switch (prg->list.ele[j]...).  
Vediamo in base al tipo... case se è TFOBJ_TYPE_INT, stampo questo... virgola... 
Eh, i... break. default: Se non è nessuno di  questa roba qui, stampiamo un punto interrogativo. 
Ehm, ogni volta che stampo un elemento,  magari ci metto uno spazio dopo. Vabbè,  
ci sarà uno spazio in più alla fine, chi  se ne frega. Questa è solo una prova. 
Eh, switch (o->type). Attenzione,  io voglio controllare il tipo. 
E questo è un size_t e deve rimanere un size_t. 
incompatible pointer... exec... exec... io  voglio eseguire il programma, non program...  
scusate, questo era un errore di prima. Ok, il programma compila. Che funzioni,  
ho qualche dubbio, ma vedremo. Allora, io per fare funzionare 'sto  
coso facciamo program.tf. TF. Il nostro programma  facciamo che è semplicemente 5 10 20. 5 10 20... 
stampa effettivamente tre numeri,  ma sono sbagliati. Perché? Guardate,  
perché quando io praticamente faccio  il parsing del mio numero... parse... 
atoi(buff), createIntObject. Allora,  dobbiamo andare a vedere dov'è che sbagliamo. 
Veramente mi sembrava di saperlo, ma in  realtà non lo so. Vediamo se questi buffer   qui sono correttamente settati al numero. Sì, 5 10 20, stampa. Quindi qua facciamo il  
parsing in maniera corretta. Vediamo qua se, ehm, o->i è veramente il numero che noi di cui facciamo  
il parsing. E fin qua ci siamo. Quindi parseNumber avviene qui. 
Eh, prima di fare questa listPush, controlliamo di  nuovo che il nostro oggetto abbia veramente quello  
che noi ci aspettiamo che ci sia là dentro e ci siamo anche qua. Andiamo a vedere  
che la listPush abbia senso. realloc, eccetera eccetera.  
sizeof(tfobj*)... list.len + 1...  l->list.ele[l->list.len]... e poi incremento 
e anche questo sembra essere sensato.  Vediamo qua che cosa stiamo facendo. 
Allora, facciamo un'altra cosa. Quando io faccio  parseNumber e ho visto che c'è veramente quello  
che vorrei prima del push, mi faccio stampare i puntatori. Guardate, questo praticamente ha  
l'effetto di... No, scusate, facciamo  una cosa. gcc ... a.out program.tf,  
così con un'esecuzione sola. Questi sono i puntatori. Io   gli stessi puntatori di questi oggetti li voglio  andare a trovare e li voglio andare a trovare qui. 
Ah, ragazzi, scusate, avevo sbagliato una  cosa banalissima. Quindi andiamo a cancellare   questo che non mi serve più a niente. Qui l'oggetto... non è che questo prg  
è il mio programma. Ehm, quindi object... tfobj *o = ... questo. Quindi l'oggetto  
della lista attuale è questo qua. Quindi  scriviamo qua o->type e qua scriviamo o->i. 
Ah, perfetto, sta funzionando,  guardate. 5 10 e 20.  Quindi ho, diciamo, una parvenza di  compilazione di questo programma qua. 
Poi ci sono delle cose che noi non  stiamo gestendo. Attenzione, per esempio,   qui se io ho un problema di parsing, fixme: release parsed here. Qua c'era  
un memory leak, tanto per iniziare, eccetera. Però guardate, lo vedete come dal nulla siamo  
passati al fatto che c'è in memoria una  rappresentazione di questo programma. 
Se già lo volessimo eseguire veramente con  la nostra exec, ogni volta che troviamo un   intero, andiamo a popolare quello stack. Già è in maniera super embrionale l'inizio  
di qualcosa. Nelle prossime puntate  vedremo cos'è questo qualcosa. Ciao.


